init()
{
level.lb_file = "leaderboards/" + getDvar("mapname") + ".txt";
if(!io::file_exists(level.lb_file))
{
io::write_file(level.lb_file, "0|None|None");
}
chat::register_command("!lb", ::cmd_lb, true);
level thread watch_game_over();
}
cmd_lb(args)
{
lb_data = read_lb();
if(lb_data.size == 0 || (lb_data.size == 1 && lb_data[0].round == "0"))
{
self tell("^2No records found for this map yet!");
return;
}
self tell("^6-- Highest Rounds --");
for(i = 0; i < lb_data.size && i < 5; i++)
{
entry = lb_data[i];
self tell("^2#" + (i + 1) + ": Round " + entry.round + " ^6" + entry.players + " ^2(" + entry.date + ")");
}
}
watch_game_over()
{
level waittill("end_game");
wait 0.05; 
final_round = level.round_number;
player_names = "";
players = getPlayers();
for(i = 0; i < players.size; i++)
{
player_names += players[i].name;
if(i < players.size - 1) player_names += " & ";
}
current_time = getDvar("date");
if(!isDefined(current_time) || current_time == "") current_time = "Unknown Date";
update_leaderboard(final_round, player_names, current_time);
}
update_leaderboard(round, names, time)
{
lb = read_lb();
if(lb.size == 1 && lb[0].round == "0")
{
lb = [];
}
new_entry = spawnStruct();
new_entry.round = int(round);
new_entry.players = names;
new_entry.date = time;
lb[lb.size] = new_entry;
for(i = 0; i < lb.size; i++)
{
for(j = i + 1; j < lb.size; j++)
{
if(int(lb[j].round) > int(lb[i].round))
{
temp = lb[i];
lb[i] = lb[j];
lb[j] = temp;
}
}
}
save_str = "";
for(i = 0; i < 5 && i < lb.size; i++)
{
save_str += lb[i].round + "|" + lb[i].players + "|" + lb[i].date + "\n";
}
io::write_file(level.lb_file, save_str);
}
read_lb()
{
if(!io::file_exists(level.lb_file)) return [];
raw = io::read_file(level.lb_file);
if(!isDefined(raw) || raw == "") return [];
lines = strTok(raw, "\n");
entries = [];
for(i = 0; i < lines.size; i++)
{
parts = strTok(lines[i], "|");
if(parts.size < 3) continue;
s = spawnStruct();
s.round = parts[0];
s.players = parts[1];
s.date = parts[2];
entries[entries.size] = s;
}
return entries;
}